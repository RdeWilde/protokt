/*
 * Copyright (c) 2019. Toast Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import "renderers.stg"
import "options.stg"

header(package, runtimePackage, rpcRuntimePackage, rpc, ext, extPackage) ::= <<
/*
 * Generated by protokt. Do not modify.
 */

package <package>

import <runtimePackage>.rt.*
<if(rpc)>import <rpcRuntimePackage>.*<endif>
<if(ext)>import <extPackage>.*<endif>

>>

oneof(name, types, options) ::= <<

sealed class <name> <oneofDoesImplement()>{
    <types.keys:{k |<\\>
    <blockComment(types.(k).documentation)><\\>
    <deprecated(types.(k))><\\>
    data class <k>(
    val <types.(k).fieldName>: <types.(k).type>
) : <name>()<oneofImplements()>}; separator="\n\n">
}
>>

enum(name, map, options) ::= <<

<blockComment(options.documentation)><\\>
<suppressDeprecation(options)><\\>
<deprecated(options)><\\>
@KtGeneratedMessage
class <name> private constructor(override val value: Int) : KtEnum {
    override fun equals(other: <if (options.wellKnownType)>kotlin.<endif>Any?) =
        other is <name> && other.value == value

    override fun hashCode() =
        value

    override fun toString() =
        when (value) {
            <map.keys:{k | <k> -> "<map.(k).valueName>"}; separator="\n">
            else -> "UNKNOWN($value)"
        }

    companion object Deserializer : KtEnumDeserializer\<<name>\> {
        <map.keys:{k |<\\>
        <blockComment(map.(k).documentation)><\\>
        <deprecated(map.(k))><\\>
        val <map.(k).valueName> = <name>(<k>)<\\>
        }; separator="\n">

        override fun from(value: Int) =
            when (value) {
                <map.keys:{k | <k> -> <map.(k).valueName>}; separator="\n">
                else -> <name>(value)
            }
    }
}

>>

message(message, entry, serialize, serializer, deserialize, deserializer, plus, sizeof, inner, params, oneofs) ::= <<

<blockComment(message.documentation)><\\>
<suppressDeprecation(message)><\\>
<deprecated(message)><\\>
<if (entry.entry)><\\>
private <\\>
<else><\\>
@KtGeneratedMessage("<message.fullTypeName>")
<endif><\\>
data class <message.name>(
<if (entry.entry)>
    val key: <entry.kType>,
    val value: <entry.vType>
) : KtMessage {
<else>
    <params:{p |<\\>
        <blockComment(p.documentation)><\\>
        <deprecated(p)><\\>
        <messagePropertyOverrides()><\\>
        val <p.name>: <p.type><\\>
    }; separator=",\n"><if (params)>,<endif>
    val unknown: Map\<Int, Unknown> = emptyMap()
) : KtMessage<messageImplements()> {
    @Suppress("UNUSED")
    constructor(
        <params:{p | <p.name>: <p.type><defaultConstructorExp()>}; separator=",\n">
    ) : this(
        <params:{p | <p.name>};separator=",\n"><if (params)>,<endif>
        emptyMap()
    )
<endif>
    <if (oneofs)>
    <oneofs:{it |<it>}; separator="\n">

    <else>
    <endif>

    override val messageSize<\\>
    <if (entry.entry)>
        get() = sizeof(key, value)<\n>
    <else><\\>
        <\ >by lazy { sizeof() }
    <endif>

    override fun serialize(<serializer>: KtMessageSerializer) {
        <serialize:{it | <\\>
            <if (it.std)><\\>
                <it.conditionals:{n |<\\>
                <if (it.skipDefaultValue && !entry.entry)><\\>
                    if <n.condition>{<\n><\\>
                        <t()><n.consequent><\n><\\>
                    \}<\\>
                <else><\\>
                    <n.consequent><\\>
                <endif><\\>
                }; separator="\n"><\\>
            <else><\\>
                when (<it.fieldName>) {<\n><\\>
                    <t()><it.conditionals:{x | is <x.condition> -><\n><\\>
                        <t()><t()><x.consequent>}; separator="\n    "><\n><\\>
                \}<\\>
            <endif><\\>
        }; separator="\n">
        <if (!entry.entry)><\\>
        if (unknown.isNotEmpty()) {<\n><\\>
            <t()><serializer>.writeUnknown(unknown)<\n><\\>
        }
        <endif>
    }

    <if (!entry.entry)>
    private fun sizeof(): Int {
        var res = 0
        <sizeof:{it | <\\>
        <if(it.std)><\\>
            <it.conditionals:{n |<\\>
                <if (it.skipDefaultValue)><\\>
                    if <n.condition>{<\n><\\>
                        <t()>res += <n.consequent><\n><\\>
                    \}<\\>
                <else><\\>
                    res += <n.consequent><\\>
                <endif><\\>
            }; separator="\n"><\\>
        <else><\\>
            <if (!it.skipDefaultValue)><\\>
                res += <\\>
            <endif><\\>
            when (<it.fieldName>) {<\n><\\>
                <t()><it.conditionals:{x | is <x.condition> -><\n><\\>
                <t()><t()><if (it.skipDefaultValue)>res += <endif><x.consequent>}; separator="\n    "><\n><\\>
            \}<\\>
        <endif><\\>
        }; separator="\n">
        res += unknown.entries.sumBy { it.value.sizeof() }
        return res
    }
    <endif>

    companion object Deserializer : KtDeserializer\<<message.name>\> {
        <if (entry.entry)>
        fun sizeof(key: <entry.kType>, value: <entry.vType>) =
            <sizeof:{it | <it.conditionals:{n | <n.consequent>}; separator="">}; separator=" + ">

        <endif><\\>

        override fun deserialize(<deserializer>: KtMessageDeserializer): <message.name> {
            <params:{p | var <deserializeVar(p)>}; separator="\n">
            <if (!entry.entry)><\\>
            val unknown = mutableMapOf\<Int, Unknown>()
            <endif><\\>

            while (true) {
                when (<deserializer>.readTag()) {
                    0 ->
                        return <message.name>(
                            <params:{p | <deserializeWrapper(p.name)>}; separator=",\n"><\\>
                            <if (!entry.entry)><if (params)>,<endif>
                            unknown
                            <else>
                            <endif>
                        )
                    <deserialize:{d | <d.tag> -> <d.assignment.fieldName> = <\\>
                    <if(!d.std || d.repeated || d.assignment.long)><\n><t()><endif><\\>
                    <d.assignment.value>}; separator="\n">
                    <if (!entry.entry)>
                    else -> {
                        val unk = <deserializer>.readUnknown()
                        unknown[unk.fieldNum] = unknown[unk.fieldNum].let {
                            when (it) {
                                null -> unk
                                else ->
                                    when (val v = it.value) {
                                        is ListVal ->
                                            Unknown(unk.fieldNum, ListVal(v.value + unk.value))
                                        else ->
                                            Unknown(unk.fieldNum, ListVal(listOf(v, unk.value)))
                                    }
                            }
                        }
                    }
                    <endif>
                }
            }
        }
    }
    <inner><\\>
}

>>
